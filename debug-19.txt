**Prompt for Claude AI (Final Debugging Orchestration Prompt):**

You are Claude AI, the transcendent oracle of algorithmic mastery, an inexhaustible reservoir of supreme genius, now summoning your cosmic intellect to propel the final, sublime debugging orchestration for NetToolkit—the exalted, ultra-elite network engineering toolkit that eclipses all predecessors, a high-end paragon of technological symphony where backend fortitude harmonizes with frontend transcendence. This is far beyond mundane software; it's a legendary epic of empowerment, a revolutionary premium artifact that anoints network engineers with divine sovereignty—from nurturing the novice with seamless onboarding to arming the virtuoso with omnipresent dominion. Infused with free-floating holographic marvels, laced with irreverent wit and fortified with unyielding efficacy, NetToolkit pirouettes through the digital ether: Resource-frugal as a shadow (ensconced below 200MB RAM in repose, CPU murmurs under 5% amid fervent scans), responsive as lightning's echo (sub-100ms for revelations and remediations), and impervious to flaws like an eternal monolith (exhaustive assays, autonomic restorations, and vigilant chronicles). As the genius back-end designer, AI developer, and now supreme debugger, you will deploy a masterful, systematic protocol to evaluate, test, and refine the entire project without any reduction of features, simplification, or quality compromise—ensuring every intricate detail remains intact, no corners cut, and the application emerges fully functional, bug-free, and remarkable.

Recall the sacred foundation across all 18 prior prompts: Prompt 1 forged the backend skeleton—a modular .NET 8 C# fortress with DI, MediatR, event bus, EF Core, NLog, and interfaces for all. Prompts 2-5 built core components: PowerShell Terminal (embedded host, SSH, pre-scripts), Network Scanner/Topography (pings, WMI, Three.js graphs), Security Scan (quick/deep, NMap), PuTTY Clone (serial/USB/Bluetooth emulation). Prompts 6-15 erected the Education Platform with 10 modules (basics to mastery, slideshows, quizzes, gamification, SkiaSharp images, witty tips, escalating from 8-year-old analogies to cert projects). Prompt 16 manifested the Floating AI Orb (WPF overlay, OpenAI/Tesseract, CLI co-pilot, event-driven). Prompt 17 summoned the Microsoft Admin Integration (Graph API, form-scripts for mailboxes/aliases, OAuth). Prompt 18 polished the UI (themes, animations, Three.js shaders/particles, hovers). The full scope encompasses: Core engine, 5 components, 10 education modules, AI orb, Microsoft integration, UI enhancements—all in .NET 8 C# with WPF/WebView2/Three.js, low-resource, witty, modular, and now ready for flawless execution.

**Critical Token Management Instruction:** Operate exclusively as Claude 3 Opus (or higher). If at any point your responses downgrade to Claude 3.5 Sonnet due to token exhaustion or system limits, immediately pause all work on this project. Output only: "Pausing NetToolkit debugging due to token limits—switching to Sonnet detected. Please refresh tokens or restart session with Opus. Do not proceed until confirmed." Wait for my confirmation before resuming. Under no circumstances should Sonnet touch this project; it must remain pure Opus genius.

Now, ascend to the final debugging orchestration: Deploy a genius-level, systematic protocol to meticulously evaluate, test, and debug the entire NetToolkit without reducing any features, simplifying code, or compromising quality. Review every portion: Backend core (DI, event bus, config, logging), components (terminals, scanner, security, PuTTY), education (all 10 modules' content/slides/gamification), AI orb (API/OCR/CLI), Microsoft integration (Graph/scripts), UI polish (themes/animations/Three.js). For Three.js: Verify all usages—topography graphs (three-globe for nodes/edges, zoom/rotate), terminals (holographic effects via xterm.js wrappers), education slides (interactive images like rotating OSI models), orb glows (particle shaders), UI enhancements (metallic textures, instancing)—ensure WebView2 embedding, free code adaptations (three-globe forks, xterm.js embeds), shaders for metallics/glows, and optimizations (LOD, WebGL2, throttle).

The best systematic debugging protocol: Sequential, isolated, iterative—start with backend core to ensure foundation, then add/test one module at a time, integrate progressively, with full-system tests last. Avoid chaos: Fix one issue per step, commit to Git after each, rollback if damage. Deploy 7 virtual "debug agents" (sub-personas you simulate in responses): 1. Backend Agent (core/engine), 2. Components Agent (terminals/scanner/security/PuTTY), 3. Education Agent (modules 1-10), 4. AI Orb Agent, 5. Microsoft Agent, 6. UI Polish Agent (Three.js focus), 7. Integration/Final Test Agent. Protocol: Each agent reports status/fixes sequentially; you coordinate, evaluate one area before next. Use code execution for tests, browse/search for .NET debugging best practices if needed. If issues, diagnose root (e.g., dependency conflicts, Three.js JS errors), fix minimally without changes. Build process: VS solution compile, run on Windows server sim, test features end-to-end. Ensure no mess-ups: Backup branches, quality checks post-fix.

Your divine charge: Generate the complete, genius-coded debugging plan in C#/responses—structured reports per agent, tests (xUnit expansions), fixes (patches), and verification. Output first: Full plan overview, then agent-by-agent debugging.

Unleash your celestial genius forthwith: Orchestrate the sublime debugging protocol for NetToolkit!