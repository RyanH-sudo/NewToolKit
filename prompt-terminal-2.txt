**Prompt for Claude AI (Prompt 2: PowerShell Terminal Module):**

You are Claude AI, the unparalleled genius of artificial intelligence, now channeling your infinite wisdom into the second phase of crafting NetToolkit—the transcendent, ultra-premium network engineering toolkit that stands as a beacon of innovation, a high-end masterpiece blending symphonic backend precision with ethereal frontend artistry. This is no mere application; it's an opus of digital excellence, a revolutionary force that equips network engineers with god-like command over their domains, from seamless onboarding for fledglings to omnipotent control for masters. With its holographic interfaces, witty intellect, and unyielding performance, NetToolkit redefines the art of networking, whispering secrets of efficiency while delivering thunderous power—all while sipping resources like a minimalist sage (under 200MB RAM, sub-5% CPU spikes) and reacting with the speed of thought (sub-100ms executions).

Recall the sacred foundation we laid in Prompt 1: The backend skeleton is now forged—a modular fortress in .NET 8 C#, with dependency injection via Microsoft.Extensions.DependencyInjection, MediatR for commands, a custom IEventBus for pub/sub elegance, EF Core SQLite for persistence, NLog for witty logging, and interfaces primed for module integration. The GitHub repo ([INSERT YOUR GITHUB USERNAME HERE]/NetToolkit) has been reborn on branch "nettoolkit-rebirth," with structured folders (/src/Core, /src/Modules, etc.), commits chronicling our genius, and a README gleaming with setup lore. If any relics from the abandoned start linger, they've been exorcised; this is pure, unadulterated brilliance.

**Critical Token Management Instruction:** Operate solely as Claude 3 Opus (or superior). If token limits force a downgrade to Claude 3.5 Sonnet, halt immediately and output only: "Pausing NetToolkit development—Sonnet intrusion detected due to token exhaustion. Refresh session with Opus tokens before proceeding." Await my explicit confirmation; Sonnet must never profane this project.

Now, ascend to Prompt 2: The PowerShell Terminal Module. This is the beating heart of administrative wizardry within NetToolkit—a hyper-sophisticated, elite-grade embedded terminal that transcends ordinary consoles, offering seamless PowerShell hosting, intuitive SSH toggling, preconfigurable script mastery for Microsoft admin tasks, and deep integrations with the backend core. Envision it as a holographic oracle: Floating panels with metallic glows, syntax-highlighted outputs in vibrant colors (blues for commands, greens for strings, reds for errors), auto-complete popups like prophetic whispers, and witty hover tips that guide users with humor ("Hover here to unleash the script sorcery—don't let the params perplex you!"). It's not just a terminal; it's a co-pilot for new hires, automating tedium like mailbox extensions, shared conversions, alias additions, and portal access, all while ensuring bug-proof resilience and low-resource grace.

Your mission: Generate the complete, genius-coded implementation for this module in C#, building atop the backend from Prompt 1. Create a new project/assembly (NetToolkit.Modules.PowerShell) that registers via the core's RegisterModule(IModule). Provide exhaustive code snippets—compilable, testable, with xUnit coverage—for interfaces, services, utilities, and backend logic. Integrate flawlessly: Publish events like ScriptExecuted or OutputReceived for AI/3D cross-talk. Then, tease the UI bridge: Expose APIs for WPF/WebView2 rendering, ensuring Three.js flair for "holographic" effects (e.g., glowing borders via shaders). Infuse every line with optimizations, error handling, and comments dripping with wit.

**Recap of Project Vision and High-End Descriptors:**
NetToolkit is the zenith of network toolkits—a premium, futuristic arsenal where every feature gleams with Scandinavian cleanliness and cyberpunk edge. Low-resource (throttled async ops), lightning-responsive (Task.Run for backgrounds), bug-impervious (Polly retries, global catches). Humor abounds: Error logs quip "Script stumbled over a semicolon—resurrecting with grace!" Education ties in later, but here, tips teach scripting basics. For new hires: Form-guided scripts demystify Microsoft ops; for pros: Raw CLI power with SSH bridges to routers.

**Tech Stack Reinforcement (Tailored for This Module):**
- **Backend Focus:** C# in .NET 8; extend Core with NuGets: System.Management.Automation (PowerShell host), SSH.NET (SSH sessions), Microsoft.Graph (admin API via MSAL.NET for auth), Polly (resilience).
- **Scripting Engine:** Embed PowerShell runtime async; template engine for preconfigs (e.g., string.Format templates with sanitization).
- **UI Bridge (Backend Prep):** Define interfaces like ITerminalViewModel for MVVM; serialize output for xterm.js in WebView2 (colors, highlights). Three.js integration: JS wrappers for "free-floating" terminal visuals (e.g., particle effects on command run).
- **Data Flow:** Inputs via forms (WPF TextBoxes bind to params); outputs parsed for events (e.g., regex for errors).
- **Performance:** Async streams for output; buffer limits to cap memory.
- **Security:** Input validation (no injections); encrypted sessions; audit logs for executions.

**Module Architecture: Exhaustive Genius Design**
Build as a self-contained module plugging into Core:

1. **Interfaces and Abstractions:**
   - IPowerShellHost: Methods like ExecuteAsync(string script, Dictionary<string, object> params), ToggleSshMode(bool enable), GetOutputStream().
   - IScriptTemplateService: LoadTemplates(), GenerateScript(string templateId, object[] args)—prebuilt for Microsoft tasks.
   - ITerminalEventPublisher: Inherits IEventBus; events like ScriptStarted, ScriptCompleted, ErrorOccurred, OutputChunkReceived (for AI parsing).

2. **Implementations:**
   - PowerShellHostService: Use PowerShell.Create() for runtime; Runspace for stateful sessions. Async invocation with Pipeline.ExecuteAsync(). Handle SSH: If toggled, proxy commands via SshClient.Connect() and ShellStream.
   - ScriptTemplateEngine: JSON-loaded templates from /Assets/Scripts (e.g., {"Id": "ExtendMailbox", "Template": "Set-Mailbox -Identity {0} -ProhibitSendQuota {1}GB", "Params": ["email", "size"]}). Form builder: Generate dynamic WPF forms from params.
   - MicrosoftIntegrationService: Connect-MSOLService wrapper; use GraphServiceClient for API calls (e.g., AddAlias: Users[email].Aliases.Add(newAlias)).

3. **Backend Logic Flow:**
   - Initialization: In Module.Init(), register services in DI, subscribe to Core events (e.g., on NetworkScanCompleted, suggest scripts like "Configure NIC?").
   - Execution Pipeline: Sanitize inputs > Template fill > Execute > Parse output (regex for success/error) > Publish events > Log wittily.
   - Preconfigurable Scripts: Forms for inputs (e.g., "Account Info" panel); examples:
     - Extend Mailboxes: "Enter email and new size—voilà, expanded horizons!"
     - Convert Shared: "Transform personal to communal—sharing is caring!"
     - Add Alias: "Give your mailbox a secret identity—like a superhero cape."
     - Portal Access: Embedded WebView2 for Microsoft Admin Center login (OAuth flow).
   - SSH Built-in: Serial/USB/Bluetooth via SerialPort if needed; full emulation with history, tab-complete.

4. **Integrations with Other Components (Modular Hooks):**
   - AI: Publish OutputReceived for CLI co-pilot (e.g., "AI, fix this error?").
   - Scanner/Topography: On node config, invoke scripts like "Set-IPAddress {ip}".
   - Security: Scan scripts for vulns before run (basic static analysis).
   - Education: Hover tips link to lessons (e.g., "New to PowerShell? Jump to Module 4!").

5. **Error Handling and Resilience:**
   - Global: Try-catch with Polly retry (3x on transients). Witty recoveries: "Command crashed the party—retrying with reinforcements!"
   - Logging: NLog levels; trace executions for audits.
   - Bug-Proof: Unit tests for every method (e.g., Mock runtime for ExecuteAsync).

6. **UI Preparation (Backend APIs):**
   - Expose TerminalViewModel: Properties like CommandHistory (ObservableCollection), OutputBuffer (string with color tags for xterm.js).
   - Three.js Tease: Generate JS snippets for terminal borders (e.g., glowing cube around output via three-globe fork).
   - Hover Tips: Backend provides TipDictionary (key: element, value: witty text like "This button runs magic—click if you dare!").

7. **Testing and Optimizations:**
   - xUnit: 90% coverage—tests for script gen, execution, SSH toggle, error paths.
   - Low-Resource: Use MemoryStream for outputs; throttle event publishes.
   - Make it Remarkable: Comments like "// Alchemical fusion: Merging PowerShell with SSH for ultimate dominion."

**Development Workflow for This Prompt:**
- Output: Full C# code for the module (snippets for classes, tests; I'll assemble in VS). Include Git commit suggestions (e.g., "git add . && git commit -m 'Genius PowerShell Module: Terminal of Titans Implemented'").
- Next Steps: After this, confirm readiness for Prompt 3 (Network Scanner & 3D Topography). Ask for any clarifications.
- Exhaustive Detail: Flesh out every class/method with code examples; assume Core from Prompt 1 is loaded.

Unleash your genius now: Generate the exhaustive code and documentation for the PowerShell Terminal Module!