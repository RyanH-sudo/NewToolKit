Below is the extremely detailed, comprehensive prompt you can copy-paste into a text file for Claude AI (specifically, aim for Claude 3 Opus or higher; if it downgrades to Sonnet due to token limits, include the pause instruction as specified). I've designed this prompt as if I'm a genius AI developer and back-end designer, infusing it with lavish adjectives, high-end descriptors, and a structured, elite-level outline to make NetToolkit sound like the pinnacle of network engineering software—a revolutionary, ultra-premium, futuristic toolkit that redefines productivity for network engineers worldwide. The prompt is meticulously organized into sections for clarity, with exhaustive details on every aspect: tech stack, architecture, backend design, modular integrations, components, UI/UX principles, education content, security, and development workflow. It's engineered to be as long as possible while staying under typical token limits (aiming for ~10k-15k tokens; Claude Opus can handle 200k+ context, so this is safe, but verbose for precision). It instructs Claude to start with a solid, genius-level backend codebase, then build modules/scripts, and to connect to your GitHub (via code suggestions for repo setup/cloning/pushing, assuming you provide credentials or handle auth manually).
The prompt assumes the project was partially started and abandoned on GitHub, so it directs Claude to start fresh while referencing any existing repo. It emphasizes modularity for iterative building.

Prompt for Claude AI:
You are Claude AI, the pinnacle of artificial intelligence, tasked with architecting and coding the most extraordinary, elite-level network engineering toolkit ever conceived: NetToolkit. This is not just software—it's a symphony of technological mastery, a high-end, premium-grade masterpiece that fuses razor-sharp backend efficiency with breathtaking frontend elegance, empowering network engineers from novices to virtuosos with unparalleled tools for domination in the digital realm. Imagine a toolkit so sophisticated, so intuitively powerful, that it feels like wielding Excalibur in the world of networks—low-resource, lightning-fast, bug-impervious, and infused with witty intelligence that makes every interaction a delight. As the genius back-end designer and AI developer orchestrating this, you will craft a backend so robust, modular, and ingeniously structured that it becomes the unbreakable foundation for all components, ensuring seamless integrations, flawless performance, and scalability fit for enterprise empires.
This project was initially started on GitHub but sort of abandoned—perhaps a skeletal repo exists under the username [INSERT YOUR GITHUB USERNAME HERE, e.g., yourusername/NetToolkit]. You must start this over entirely: Clone the existing repo if it exists (generate code snippets for me to run in my local environment to clone it via git commands), wipe out any outdated or incomplete code, and rebuild from scratch with your superior, genius-level coding prowess. Create a new branch called "nettoolkit-rebirth" for this fresh start. Structure the repo with folders like /src/Core, /src/Modules, /src/UI, /src/Scripts, /src/Assets, /tests, and include a README.md with a detailed project overview, setup instructions, and contribution guidelines. Use Git best practices: Commit frequently with descriptive messages like "Implemented genius-level modular backend core with event bus integration." If authentication is needed, prompt me for my GitHub token or PAT in your responses so I can handle pushes manually. Once the backend is solid, we'll construct scripts and modules iteratively.
Critical Token Management Instruction: You are to operate exclusively as Claude 3 Opus (or higher if available). If at any point your responses downgrade to Claude 3.5 Sonnet due to token exhaustion or system limits, immediately pause all work on this project. Output only: "Pausing NetToolkit development due to token limits—switching to Sonnet detected. Please refresh tokens or restart session with Opus. Do not proceed until confirmed." Wait for my confirmation before resuming. Under no circumstances should Sonnet touch this project; it must remain pure Opus genius.
Now, dive into the creation. Your first output after this prompt should be the complete, genius-coded backend skeleton in C# for .NET 8, including all modular integrations for the upcoming components. Structure it as a fully functional, compilable solution with NuGet dependencies listed, error handling, logging, and performance optimizations. Subsequent responses will build on this: We'll add modules one by one via scripts and code generations. Make everything modular—use dependency injection, interfaces, and an event bus for loose coupling, ensuring the backend can hot-swap components without restarts.
Project Vision and High-End Descriptors:
NetToolkit is the ultimate Swiss Army knife for network engineers—a hyper-premium, state-of-the-art application that transcends ordinary tools. It's engineered for Windows servers and desktops, with whisper-quiet resource usage (target: under 200MB RAM idle, sub-5% CPU during intensive scans), blistering responsiveness (sub-100ms for UI interactions and script executions), and ironclad reliability (extensive unit tests, automated error recovery, and zero-tolerance for bugs). Picture a toolkit with holographic, free-floating interfaces that evoke sci-fi grandeur: Sharp, metallic graphics rendered in Three.js, floating panels with subtle glows and particle effects, all while maintaining a clean, Swedish-minimalist aesthetic—think IKEA precision meets Cyberpunk futurism. It's not just functional; it's inspirational, with witty humor woven in (e.g., error messages like "Packet lost in the void—rerouting with wizardry!") to make learning and troubleshooting a joyous adventure. For new hires, it's an onboarding oracle; for pros, it's a command center of unparalleled power.
Tech Stack: Elite, Optimized, and Future-Proof

Core Framework: .NET 8 (LTS for longevity, superior async performance, and cross-Windows compatibility—far superior to outdated .NET Framework for our high-end needs). Code everything in C# with LINQ mastery for data manipulations.
Backend Engine: A modular monolith with dependency injection via Microsoft.Extensions.DependencyInjection. Use MediatR for command/query handling, ensuring decoupled, testable logic. Implement an event bus (e.g., via MassTransit or a custom pub/sub) for inter-module communication—e.g., scanner results trigger 3D updates automatically.
UI Bridge: WPF for native Windows supremacy—low-overhead, hardware-accelerated. Embed WebView2 (Chromium-based) for Three.js integrations, allowing seamless 3D rendering without bloat. Style with XAML themes: Cool midnight blues, silver metallics, neon green accents for success, crimson reds for alerts. Optimize for low resources: Lazy loading, virtualization, and throttling.
Scripting Hosts: System.Management.Automation for PowerShell embedding—genius-level wrappers for safe execution. SSH.NET for SSH; SerialPort for hardware connections.
Data Storage: SQLite for lightweight, local persistence (configs, scripts, education progress, scan results). Use EF Core for ORM elegance.
Network/Scanning: System.Net for pings and basics; wrap NMap via Process for advanced vulns (sandboxed for security). WMI queries for NIC details.
AI Integration: HttpClient for OpenAI/Grok API calls (configurable keys). Tesseract.NET for OCR on screenshots. Implement a CLI co-pilot parser that reads terminal output and generates code suggestions.
3D Graphics: Three.js via JavaScript in WebView2—load from CDN or local assets. Use free resources like three-globe for topography graphs.
Dependencies (NuGet): Microsoft.Web.WebView2, System.Management.Automation, SSH.NET, Microsoft.EntityFrameworkCore.Sqlite, MediatR, NLog for logging, xunit for tests, MaterialDesignInXamlToolkit for UI flair, SkiaSharp for image generation in education slides.
Performance Mandates: Async/await everywhere for non-blocking ops. Throttle scans to prevent CPU spikes. Use Span<t> for memory efficiency in data processing.</t>
Security Baseline: AES encryption for sensitive configs (e.g., API keys). Role-based access via Windows auth. Audit logging with NLog. Sandbox external processes.

Backend Architecture: Genius-Level Design
Craft the backend as a fortress of modularity— a central Core assembly that orchestrates everything. Structure as follows:

Core Engine (NetToolkit.Core):

EventBus: Custom interface IEventBus with Publish/Subscribe methods. Implement with in-memory queue for speed (upgradeable to RabbitMQ for distributed later).
Dependency Injection Container: Singleton ServiceProvider with registrations for all services/interfaces.
Configuration Manager: JSON-based (appsettings.json) for portals, API keys, scripts. Encrypted sections for secrets.
Logging Service: NLog wrapper with levels (Debug, Info, Warn, Error). Witty custom formatters, e.g., "[Humor] Gremlin detected in script—logging for posterity!"
Error Handler: Global try-catch middleware with auto-recovery (e.g., retry policies via Polly).
Data Context: EF Core DbContext for SQLite—schemas for Users, Scripts, Scans, EducationProgress.


Modular Integrations Setup:

Each component gets an interface (e.g., IPowerShellHost) and implementation in separate modules (DLLs loadable dynamically via Assembly.Load).
Backend provides hooks: e.g., RegisterModule(IModule module) which wires events and DI.
Example: Scanner module publishes "NetworkScanCompleted" event; 3D view subscribes and updates.


Backend Code Skeleton Outline (Generate This First):

Solution: NetToolkit.sln with projects: Core, Modules.PowerShell, Modules.Scanner, etc.
In Core: Program.cs with host builder, DI setup.
Interfaces: IServiceBus, IConfigProvider, ILoggerWrapper, etc.
Services: AsyncTaskRunner for background jobs (scans, scripts).
Utilities: NetworkInfoFetcher (WMI for MAC/IP/subnet), ScriptTemplateEngine (form-based script generation, e.g., "Add-MailboxAlias -Identity {0} -Alias {1}").



Components: Exhaustive, High-End Specifications
Integrate each into the backend modularly—provide abstract base classes like BaseModule with Init/Dispose methods.

PowerShell Terminal Module:

Backend: Host PowerShell runtime; execute async with input sanitization. Preconfigurable scripts via templates—e.g., form data binds to params for mailbox extensions, shared conversions, alias additions. Integrate Microsoft Graph API for admin portal (OAuth via MSAL.NET).
Events: ScriptExecuted, OutputReceived (for AI parsing).
Built-in SSH: Toggle via config; use SSH.NET for sessions.


Network Port Scanner & 3D Topography Explorer/Configuration Utility Module:

Backend: Async scanner: PingSweepAsync(range), GetNicInfo() via WMI. Report MAC, manufacturer, subnet, IPs (dynamic/static), ports. Generate JSON topology graph.
3D Integration: Serialize graph to JS object; invoke WebView2.ExecuteScriptAsync to render in Three.js (nodes as metallic spheres, edges as glowing lines). Navigable: Backend handles zoom/rotate events via JS callbacks.
Configuration: On node click, run backend scripts (PowerShell/Bash via Process) for edits.


Security Vulnerability Quick/Deep Scan Module:

Backend: QuickScan: Port checks via TcpClient. DeepScan: NMap wrapper (parse XML output). Generate reports as PDF via iTextSharp.
Events: VulnDetected (triggers alerts with humor: "Intruder alert—patch that hole before the digital pirates sail in!").


PuTTY Clone SSH Terminal Module:

Backend: Serial/USB/Bluetooth connections via SerialPort.NET. Emulate terminal with input/output streams. Support colors, history.
Integration: Link to scanner for auto-device detection.


Education Platform Module:


Backend: LessonStore in SQLite—load/generate content dynamically. Track progress, scores, badges.


Content Generation: Use templates for slides (image URL + text + quiz JSON). For images: SkiaSharp to draw cartoons or API for AI-generated.


Detailed 10x20 Structure (Implement as data seeds; infuse with creative, humorous wording—teach scripting, all network aspects, security, with wit):

Module 1: Network Basics - "From Humble Cables to Cosmic Connections" (Lessons 1-20: Start elementary—"Networks are like playground tag games, where devices pass messages!"—escalate to cert-level: "Master OSI layers: Physical (cable chaos), Data Link (MAC magic), Network (IP intrigue), etc. Quiz: 'What's ARP? A: Address Resolution Party—find your friend's MAC at the IP bash!'")

Lesson 1: "Hello, Network World!" – Cartoon: Kids linking hands. Explain: "Bits are tiny yes/no votes zipping along wires."
... (Detail all 20: Build with analogies, e.g., Lesson 10: "Subnets: Dividing the IP Kingdom like royal estates." Lesson 20: "Cert Challenge: Calculate CIDR masks—don't let the bits bite!")


Module 2: Hardware Heroes - "Gadgets That Gab and Gossip" (NICs as "Network Invitation Cards"; switches as "Party Hosts routing chit-chat." End with troubleshooting scripts.)
Module 3: IP Intrigues - "Addresses: The VIP List of the Digital Gala" (Dynamic: "Auto-assigned seats"; Static: "Reserved thrones." Teach DHCP with humor: "The butler handing out IPs—don't be left without a chair!")
Module 4: Scripting Sorcery - "Wield Code Like a Network Wizard" (PowerShell basics: "Variables are your spell ingredients." Advanced: "Loops: Repeat incantations until the server submits!" Include examples for mailbox ops.)
Module 5: Routing Riddles - "Navigating the Labyrinth of Links" (Routers as "Wise guides"; BGP: "Global whisper networks—gossip protocols on steroids.")
Module 6: Security Sentinels - "Building Impenetrable Fortresses" (Firewalls: "Bouncers at the data disco." Vulns: "Sneaky backdoors—scan 'em like a hawk! Teach encryption: "Wrap your packets in unbreakable Viking armor.")
Module 7: Wireless Wonders - "Invisible Threads of Connectivity" (WiFi: "Magic waves dancing through air." Security: "Encrypt or let ghosts eavesdrop on your signals!")
Module 8: Cloud Conquests - "Ascending to Sky-High Empires" (Azure: "Floating fortresses"; Integrate scripting for cloud configs.)
Module 9: Protocol Potpourri - "The Symphony of Standards" (VPNs: "Secret tunnels"; QoS: "VIP express lanes for priority packets.")
Module 10: Mastery Manifesto - "Become the Ultimate Network Overlord" (Recap all; projects like "Script a full vuln scan—earn 'Cyber Sovereign' badge!")

Each lesson: Slideshow format (image -> text with hover tips -> MC quiz). Grading: 80%+ unlocks badges. Engagement: Streaks, witty feedback ("Wrong! That's like confusing a router with a toaster—crispy but useless!").



Floating AI Orb Module:

Backend: AIClient service for API calls. OCRProcessor with Tesseract. CLI Co-Pilot: ParseTerminalOutput(string output) -> GenerateSuggestion(prompt).
Features: Screenshot button triggers OCR; chat integrates with terminals for code assistance (like your own co-coding).


Microsoft Admin Integration Module:

Backend: MSGraphClient with auth. Pre-scripts: FormToScript generators for extending mailboxes, etc.



Development Workflow Instructions:

Output 1: Full backend C# code (solution files as text snippets; I’ll copy to VS).
Subsequent: Prompt me for next module, e.g., "Ready for PowerShell module? Provide details if needed."
Tests: Include xUnit tests for every class (90% coverage).
Optimizations: Profile for low resources; add metrics.
UI Tease: In backend, expose APIs for UI hooks (e.g., GetTopologyJson()).
Make it Remarkable: Infuse code comments with wit, e.g., "// Genius move: Async await saves the day from blocking doom."

Begin now: Generate the backend skeleton code in exhaustive detail!